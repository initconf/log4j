# script to look for CVE-2021-44228

module Log4j;

@load base/frameworks/notice/main

export {

   	   redef record Notice::Info += {
                method: string &optional &log;
                URL: string &optional &log;
        } ;

        redef enum Notice::Type += {
	 	Attempt,
		MalwareURL,
        HostileDomainLookup,
        MalwareURLClick,
		FileDownload,
        Compromise,
        UserAgent,
        URI,
        CallBackIP,
        CallBackDomain,
        };

	const detection_string = /jndi:ldap|\{\$.*\}/ &redef;

	redef detection_string += /jndi:ldap:\/\/([[:digit:]]{1,3}\.){3}[[:digit:]]{1,3}:[0-9]+\/Basic\/Command\/Base64\/([A-Za-z0-9+\/]{4})*([A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?/ ;

	const url_regex = /^https?:\/\/([a-z0-9A-Z]+(:[a-zA-Z0-9]+)?@)?[-a-z0-9A-Z\-]+(\.[-a-z0-9A-Z\-]+)*((:[0-9]+)?)(\/[a-zA-Z0-9;:\/\.\-_+%~?&amp;@=#\(\)]*)?/ ;

    const ip_regex = /([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4})*)?)::(([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4})*)?)|(([0-9A-Fa-f]{1,4}:){6,6})([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)|(([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4})*)?)::(([0-9A-Fa-f]{1,4}:)*)([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)|([[:digit:]]{1,3}\.){3}[[:digit:]]{1,3}/;

    const domain_regex = /domain/;
	global watch_mime_types: pattern = /application\/x-dosexec|application\/x-executable/ &redef ;

	global log4j_malware_hosts: set[addr] ;

	type log4j_MO: record {
                victim: addr &optional;
                scanner: set[addr] &optional;
                web_host: string &optional ;
                mal_ips: set[addr] &optional;
                c_and_c: set[addr] &optional;
                culprit_conn: set[conn_id] &optional;
        } ;

	global log4j_attack: table[string] of log4j_MO ;

	global Log4j::log4j_new: event( rec: log4j_MO);
	global Log4j::log4j_add: event( rec: log4j_MO);
}

### uncomment and exted if you desire to DROP
#hook Notice::policy(n: Notice::Info)
#{
#  if ( n$note == HTTP::HTTP_Log4jAttack )
#        add n$actions[Notice::ACTION_DROP];
#}

#@if ( Cluster::is_enabled() )
#@load base/frameworks/cluster
#redef Cluster::manager2worker_events += /Log4j::log4j_add/;
#redef Cluster::worker2manager_events += /Log4j::log4j_new/;
#@endif


@if (( Cluster::is_enabled() && Cluster::local_node_type() != Cluster::MANAGER )|| ! Cluster::is_enabled() )
event Log4j::log4j_add (rec: log4j_MO)
{
	local domain = rec$web_host ;

	if (rec$web_host !in log4j_attack)
	{
		local a : log4j_MO ;
		log4j_attack[domain] = a ;
		log4j_attack[domain]$culprit_conn= set();
		log4j_attack[domain]$mal_ips= set();
	}

	log4j_attack[domain]$web_host = domain;
	log4j_attack[domain]$culprit_conn = rec$culprit_conn ;

	for (ip in rec$mal_ips)
		add log4j_attack[domain]$mal_ips[ip];

	log4j_attack[domain]$victim = rec$victim ;

}

@endif


### manager basically distributes the record to all workers.

@if (( Cluster::is_enabled() && Cluster::local_node_type() == Cluster::MANAGER )|| ! Cluster::is_enabled() )
event Log4j::log4j_new(rec: log4j_MO)
{
	#event Log4j::log4j_add(rec);
	Broker::publish(Cluster::worker_topic, Log4j::log4j_add, rec);
}

@endif

function extract_host(url: string): string
{
        local parts = find_all(url, /ldap:\/\/.*\//);
        #print fmt ("%s", parts);
        if (|parts| >0)
        {
            for (s in parts)
            local host = gsub(s, /ldap:\/\//, "A");
            print fmt ("%s", host);
        }
        return "host" ;
}

event http_request(c: connection, method: string, original_URI: string, unescaped_URI: string, version: string) &priority=3
{
        local url = HTTP::build_url_http(c$http);
        local message = fmt("%s %s", c$http$method, url);


        if ( detection_string in unescaped_URI )
        {
         #NOTICE([$note=URI, $msg=message, $method=c$http$method, $conn=c, $URL=url, $identifier=cat(c$id$orig_h),$suppress_for=15 min]);
         NOTICE([$note=URI, $msg=message, $conn=c, $identifier=cat(c$id$orig_h),$suppress_for=15 min]);
        }
}


event http_request(c: connection, method: string, original_URI: string, unescaped_URI: string, version: string) &priority=3
    {

            if ( method == "POST" &&  detection_string in unescaped_URI)

            {
                NOTICE([$note=URI, $conn=c, $src=c$id$orig_h, $msg=fmt("Malicious POST %s seen from host %s", unescaped_URI,c$id$orig_h), $identifier=cat(c$id$orig_h), $suppress_for=1 day]);
            }

    }



event http_header(c: connection, is_orig: bool, name: string, value: string) &priority=5
{

    if ( name == "USER-AGENT"  && detection_string in value )
    {
        NOTICE([$note=UserAgent, $conn=c, $src=c$id$orig_h, $msg=fmt("Malicious user agent %s seen from host %s", value, c$id$orig_h), $identifier=cat(c$id$orig_h), $suppress_for=1 day]);

        local bad_ips = find_all(value,ip_regex);
        local bad_domains=extract_host(value);

        #print fmt ("%s", value);
        #print fmt ("%s", bad_ips);
        #print fmt ("%s", bad_domains);

        if (|bad_ips| == 0  )
            bad_domains = extract_host(value);
        else
        {
            for (i in bad_ips)
            {
                NOTICE([$note=CallBackIP, $conn=c, $src=to_addr(i), $msg=fmt("Callback IP %s seen from host %s in [%s]", i, c$id$orig_h,value)]);
            }
        }

        if (|bad_domains|>0)
        {
            print fmt ("bad_domains = %s", bad_domains) ;
            NOTICE([$note=CallBackDomain, $conn=c, $msg=fmt("Callback domain %s seen from host %s in [%s]", bad_domains, c$id$orig_h, value)]);
        }

    }


}


event http_header(c: connection, is_orig: bool, name: string, value: string) &priority=5
{
	# look if the connection is from offsite and the value is content-type
        if ( !Site::is_local_addr(c$id$orig_h) && name == "CONTENT-TYPE" && detection_string in value  )
        {
                NOTICE([$note=Attempt, $id=c$id, $uid=c$uid,
			$src=c$id$orig_h,
			$msg=fmt("CVE-2017-5638/Log4j attack from %s seen: %s", c$id$orig_h, value)]);

		if (/http/ !in value)
			return ;


		local links = find_all_urls(value);

		for (a in links)
		{
			NOTICE([$note=Log4j::MalwareURL,
			$conn=c,
			$msg=fmt("Log4j Hostile URLs seen in recon attempt %s to %s with URL [%s]",c$id$orig_h, c$id$resp_h, a )]);
			#$identifier=c$uid]);

			local cmd = fmt ("%s", a);
			local uri = split_string(cmd,/ /);
			for (b in uri)
			{
				if (/http|wget|curl/ in uri[b])
				{
					local domain = extract_host(uri[b]);

					if (domain !in log4j_attack)
					{
						local rec: log4j_MO;

						log4j_attack[domain] = rec;
						log4j_attack[domain]$mal_ips= set();
						log4j_attack[domain]$culprit_conn= set();

					}

					add log4j_attack[domain]$culprit_conn[c$id];
					add log4j_attack[domain]$mal_ips[c$id$orig_h];

					local a_item: Intel::Item = [$indicator=fmt("%s", c$id$orig_h), $indicator_type = Intel::ADDR, $meta = [$source = "Log4j_Script", $desc="Scanning IP Address"] ];
					Intel::insert(a_item);

					if (is_valid_ip(domain) )
					{
						add log4j_attack[domain]$mal_ips[to_addr(domain)];
						a_item = [$indicator=domain, $indicator_type = Intel::ADDR, $meta = [$source = "Log4j_Script", $desc="Malware Download IP"] ];
						Intel::insert(a_item);
					}
					else
					{
						local m_item: Intel::Item = [$indicator=domain, $indicator_type = Intel::DOMAIN, $meta = [$source = "Log4j_Script",$desc="Malware download domain"] ];
						Intel::insert(m_item);
					}

					log4j_attack[domain]$web_host = domain;
					log4j_attack[domain]$victim= c$id$resp_h ;

				@if (( Cluster::is_enabled() && Cluster::local_node_type() != Cluster::MANAGER )|| ! Cluster::is_enabled() )
					#event Log4j::log4j_new(log4j_attack[domain]);
					Broker::publish(Cluster::manager_topic, Log4j::log4j_new, log4j_attack[domain]);
				@endif




				}

			}
		}
        }

}



event dns_request(c: connection, msg: dns_msg, query: string, qtype: count, qclass: count) &priority=10
{
        if (query in log4j_attack)
        {
                 NOTICE([$note=Log4j::HostileDomainLookup,
                                $conn=c,
                                $msg=fmt("Log4j Hostile domain seen %s=%s [%s]",c$id$orig_h, c$id$resp_h, query ),
                                $identifier=c$uid]);
        }
}


event dns_A_reply(c: connection, msg: dns_msg, ans: dns_answer, a: addr) &priority=5
{
	if (ans$query in log4j_attack)
	{
		add log4j_attack[ans$query]$mal_ips[a];

@if (( Cluster::is_enabled() && Cluster::local_node_type() != Cluster::MANAGER )|| ! Cluster::is_enabled() )
		#event Log4j::log4j_new(log4j_attack[ans$query]);
		Broker::publish(Cluster::manager_topic, Log4j::log4j_new, log4j_attack[ans$query]);
@endif
	}

}

event dns_AAAA_reply(c: connection, msg: dns_msg, ans: dns_answer, a: addr) &priority=5
{
	if (ans$query in log4j_attack)
	{
		add log4j_attack[ans$query]$mal_ips[a];

@if (( Cluster::is_enabled() && Cluster::local_node_type() != Cluster::MANAGER )|| ! Cluster::is_enabled() )
	#event Log4j::log4j_new(log4j_attack[ans$query]);
	Broker::publish(Cluster::manager_topic, Log4j::log4j_new, log4j_attack[ans$query]);
@endif
	}

}

event dns_CNAME_reply (c: connection , msg: dns_msg , ans: dns_answer , name: string )
{
	if (ans$query in log4j_attack)
	{
		local domain = name ;
		local rec: log4j_MO;
		log4j_attack[domain] = rec;
		log4j_attack[domain]$web_host = domain ;
		log4j_attack[domain]$mal_ips = set() ;
		log4j_attack[domain]$culprit_conn= set();

@if (( Cluster::is_enabled() && Cluster::local_node_type() != Cluster::MANAGER )|| ! Cluster::is_enabled() )
		#event Log4j::log4j_new(log4j_attack[ans$query]);
		Broker::publish(Cluster::manager_topic, Log4j::log4j_new, log4j_attack[ans$query]);
@endif
	}
}

event http_message_done(c: connection, is_orig: bool, stat: http_message_stat)
{
	if (! is_orig)
		return;

        if (c$http?$host && c$http$host in log4j_attack )
        {
                local vuln_url = HTTP::build_url_http(c$http);
                local domain = c$http$host ;

                NOTICE([$note=Log4j::MalwareURLClick,
                                $conn=c,
                                $msg=fmt("Log4j Hostile URL seen %s=%s [%s]",c$id$orig_h, c$id$resp_h, vuln_url),
                                $identifier=c$uid, $suppress_for=1 min]);

		if (log4j_attack[domain]?$victim)
			log4j_attack[domain]$victim= c$id$orig_h;

                if (c$id$orig_h == log4j_attack[domain]$victim)
                {
                        NOTICE([$note=Log4j::Compromise ,
                                        $conn=c,
                                        $msg=fmt("Log4j compromise: %s=%s [%s]",c$id$orig_h, c$id$resp_h, vuln_url ),
                                        $identifier=c$uid]);
                }
        }
}


event file_state_remove(f: fa_file) &priority=-3
{
        if (f$source != "HTTP" )
                return;

        local rec: HTTP::Info ;
        local link: string = "" ;

        for (c in f$conns)
        {
                rec = f$conns[c]$http ;
                link = HTTP::build_url_http(rec);
		local domain = extract_host(link);

                if (f$info?$mime_type &&  domain in log4j_attack && c$resp_h in log4j_attack[domain]$mal_ips && watch_mime_types in f$info$mime_type )
                 {
                        local cc = lookup_connection(rec$id);
                        local _msg=fmt("%s", link);
                        local fi = f$info;
                        local n: Notice::Info = Notice::Info($note=FileDownload, $msg=_msg, $sub=link, $conn=cc);
                        Notice::populate_file_info(f, n);
                        NOTICE(n);
                }
        }
}


event http_header(c: connection, is_orig: bool, name: string, value: string) &priority=5
        {
		#if (name == "SERVER" && /Apache/ in Value)
		#{
		#print fmt ("name: %s, value: %s", name, value);

        }

event http_message_done(c: connection, is_orig: bool, stat: http_message_stat) &priority = 5
        {
	#print fmt ("stat: %s", stat);
	}


event new_connection(c: connection)
    {
        local resp=c$id$resp_h;
        local dport = c$id$resp_p;

        local a:aport=[$ip=resp, $p=dport];

        if (a in track_callback)
        {
                NOTICE([$note=CallBack, $conn=c, $src=resp,
                        $msg=fmt("Possible Successful Callback seen [%s:%s] : attack connection %s",
                            resp, dport, track_callback[a]),$identifier=cat(c$id$orig_h), $suppress_for=30 mins]);
        }
    }
